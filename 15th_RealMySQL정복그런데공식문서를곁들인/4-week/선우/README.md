## 8.1 디스크 읽기 방식

- MySQL(InnoDB)는 페이지 단위로 디스크에 접근한다. 기본 페이지 크기는 16KB
- 랜덤 I/O보다 순차 I/O가 빠르기 때문에, 버퍼 풀을 적극 활용하여 페이지 캐싱
- 읽기 요청의 단위는 다음과 같이 구분된다:
  - 논리적 I/O (버퍼 풀에서 찾기)
  - 물리적 I/O (디스크에서 직접 읽기)
- InnoDB는 Read Ahead 기능을 제공하여, 연속된 페이지를 미리 읽어 디스크 접근 횟수를 줄임
- Read-Ahead가 트리거되는 경우
  - `Range Scan` 수행
  - `Full Table Scan` 발생

### 8.1.2 순차 I/O vs 랜덤 I/O

| 구분        | 순차 I/O (Sequential I/O)              | 랜덤 I/O (Random I/O)                  |
|-------------|----------------------------------------|----------------------------------------|
| 정의        | 연속된 디스크 블록을 순서대로 접근     | 불규칙한 위치의 블록을 이곳저곳 접근 |
| 성능        | 빠름 (헤더 이동 최소화)                | 느림 (헤더 이동 많음)                 |
| 동작 방식   | 디스크 헤더가 한 번만 움직임           | 매번 디스크 헤더가 새 위치로 이동     |
| 활용 예     | 테이블 풀스캔, 정렬된 인덱스 스캔       | 특정 PK 조회, 범위 밖 다건 조회       |

> **💡 참고:**  
> MySQL에서는 인덱스를 통한 랜덤 I/O가 항상 빠른 것은 아니다.  
> 조건이 많고 선택도가 낮으면 **풀스캔(순차 I/O)**이 더 빠르기도 한다.

- 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다. 즉, 필요한 데이터만 읽도록 쿼리를 개선하는 것을 말한다.

## 8.2 인덱스란?

### B-Tree (정확히는 B+Tree)

| 항목         | 내용 |
|--------------|------|
| 구조         | 균형 잡힌 다진 트리 (Balanced Tree) 구조. 리프 노드에 데이터가 저장됨 (B+Tree) |
| 특징         | 정렬된 상태 유지. 범위 검색과 정렬이 빠름 |
| 사용처       | MySQL 기본 인덱스 (InnoDB의 PK, 보조 인덱스 모두) |
| 장점         | 범위 검색 가능, 정렬 효율적 |
| 단점         | 정확히 일치하는 값만 자주 찾을 경우는 해시보다 느릴 수 있음 |

### R-Tree

| 항목   | 내용 |
|--------|------|
| 구조   | 다차원 공간을 다루는 트리. 공간 데이터를 포함한 사각형 영역 최소 단위로 구성 |
| 특징   | 2D 이상 좌표 기반의 범위 검색에 특화 |
| 사용처 | MySQL의 `SPATIAL INDEX` (GIS 데이터), `MyISAM` 엔진에서만 사용 가능 |
| 장점   | 공간 데이터 처리에 최적 |
| 단점   | 일반 숫자/문자 검색에는 부적합, InnoDB에서는 사용 불가 (8.0부터 일부 가능) |

### Hash Index

| 항목   | 내용 |
|--------|------|
| 구조   | 해시 함수를 통해 key → bucket으로 변환 |
| 특징   | 동등 비교(=)만 빠름. 범위 검색, 정렬 불가 |
| 사용처 | MEMORY 엔진에서 기본 사용 |
| 장점   | 정확한 일치 검색에 매우 빠름 |
| 단점   | > / < / BETWEEN / ORDER BY 등 불가능, 충돌 시 성능 저하 |

## 8.3 B-Tree 인덱스
- InnoDB가 압축할 때 사용할 블록 크기를 지정하는 옵션이다.
- 압축 단위가 "페이지(16KB 전체)"가 아니라, 4KB 또는 8KB "블록" 단위로 압축을 수행한다.
