# 06. 데이터 압축

MySQL 서버에서 디스크에 저장된 데이터 파일의 크기는 일반적으로 쿼리의 처리 성능과도 직결되지만 백업 및 복구 시간과도 밀접하게 연결된다.
- 디스크의 데이터 파일이 크면 클수록 쿼리를 처리하기 위해서 더 많은 데이터 페이지를 InnoDB 버퍼 풀로 읽어야 할 수도 있다.
- 새로운 페이지가 버퍼 풀로 적재되기 때문에 그만큼 더티 페이지가 더 자주 디스크로 기록돼야 한다.
=> 이런 문제점을 해결하기 위해 데이터 압축 기능을 제공한다.

MySQL 서버에서 가능한 압축 방식은 1. 데이터 압축과 2. 페이지 압축 두 가지가 있다.

## 6.1 페이지 압축
- Transparent Page Compression이라고도 불리는데, MySQL 서버가 디스크에 저장하는 시점에 데이터 페이지가 압축되어 저장되고, 반대로 MySQL 서버가 디스크에서 데이터 페이지를 읽어올 때 압축이 해제된다.
  - 즉 버퍼 풀에 데이터 페이지가 한 번 적재되면 InnoDB 스토리지 엔진은 압축이 해제된 상태로만 데이터 페이지를 관리한다.
  - 한 가지 문제점은, 16KB 데이터 페이지를 압축한 결과가 용량이 얼마나 될지 예측이 불가능한데 적어도 하나의 테이블은 동일한 크기의 페이지(블록)으로 통일돼어야 한다는 것이다.

- 그래서 페이지 압축 기능은 OS별로 특정 버전의 파일 시스템에서만 지원되는 펀치 홀이라는 기능을 사용한다.

```
1. 16KB 페이지를 압축 (압축 결과는 7KB로 가정)
2. MySQL 서버는 디스크에 압축된 결과 7KB를 기록 (7KB + 9KB의 빈 데이터를 기록)
3. 디스크에 데이터를 기록한 후, 9KB에 대해 펀치 홀을 생성
4. 파일 시스템은 나머지 디스크의 9KB 공간은 다시 OS에 반납
```

### 페이지 압축이 가진 문제
- 펀치 홀 기능은 OS 뿐만 아니라 하드웨어 자체에서도 해당 기능을 지원해야 사용 가능하다.
- 또한, 파일 시스템 관련 명령어가 펀치 홀을 지원하지 못한다.
  - MySQL 서버의 데이터 파일은 해당 서버에만 머무는 것이 아니라 백업 및 복구하는 과정에서 데이터 파일 복사 과정이 실행되고 그 외에 많은 파일 관련 유틸리티들을 사용한다.
  - 예시로, 펀치 홀이 적용되어 실제 데이터 파일의 크기가 1GB라고 하지만 "cp"같은 복사 명령어 사용 시 펀치 홀이 다시 채워져서 데이터 파일의 크기는 원본 크기가 될 수 있다.

이러한 이유로 실제 페이지 압축은 많이 사용되지 않는다.

## 6.2 테이블 압축
- 테이블 압축은 운영체제나 하드웨어 제약 없이 사용이 가능해서 더 활용도가 더 높은 편이다.
- 디스크의 데이터 파일 크기를 줄일 수 있어서 그만큼의 이득은 있다. 하지만 몇 가지 단점도 있다.
  - 버퍼 풀 공간 활용률이 낮음
  - 쿼리 처리 성능이 낮음
  - 빈번한 데이터 변경 시 압축률이 떨어짐

내부적으로 어떻게 압축이 실행되어 디스크에 저장되는지, 압축된 데이터 페이지들이 버퍼 풀에 어떻게 적재되어 사용되는지 이해해보자

### 6.2.1 압축 테이블 생성
- 압축을 사용하기 위한 전제 조건은 별도의 테이블 스페이스를 사용해야 한다.
- 또한 압축을 사용하는 테이블의 경우 테이블 생성 시 ROW_FORMAT=COMPRESSED 옵션을 명시해야 한다.
- 추가로 KEY_BLOCK_SIZE 옵션을 이용해 압축된 페이지의 타겟 크기를 명시해야 한다.
  - 페이지 크기가 16KB라면 KEY_BLOCK_SIZE는 4KB 또는 8KB만 설정할 수 있다.

데이터 페이지를 압축한 용량이 얼마나 될지 알 수 없는데, 어떻게 KEY_BLOCK_SIZE를 테이블을 생성할 때 설정할 수 있을까?
- 우선 InnoDB 스토리지 엔진이 압축을 적용하는 방법을 살펴본다

```
1. 16KB 데이터 페이지 압축
- 압축된 결과가 8KB 이하이면 그대로 디스크에 저장 (압축 완료)
- 압축된 결과가 8KB 초과하면 원본 페이지를 스플릿해서 2개의 페이지에 8KB씩 저장
2. 나뉜 페이지 각각에 대한 1번 단계를 반복 실행
```

=> 원본 데이터 페이지의 압축 결과가 목표 크기 (key_block_size)보다 작거나 같을 떄까지 반복해서 페이지를 스플릿한다. 따라서 크기를 잘못 설정하면 서버 처리 성능이 급격히 떨어질 수 있다.

### 6.2.2 KEY_BLOCK_SIZE 결정
- 압축된 결과가 어느 정도가 될지를 예측해서 KEY_BLOCK_SIZE를 결정하는 것이다.
  - 압축 실패율이 높게 나올 경우 실패율을 낮출 수 있는 사이즈를 선택해야 한다.
  - 실패율이 높으면 버퍼풀에서 디스크로 기록되기 전에 압축하는 과정에 꽤 오랜 시간이 걸릴 것으로 예측할 수 있다.
  - 성능에 민감한 서비스라면 테이블 압축을 적용하는 것이 좋다고 판단할 수 있다.
  - 하지만, 압축 실패율이 높다고 해서 압축을 사용하지 말아야 한다는 것은 아니다.
    - 저장용 혹은 로그성 테이블은 최초 한번 INSERT 이후 다시 변경되지 않으므로 데이터 파일의 크기가 큰 폭으로 줄어든다면 큰 손해는 아니다.
    - 또한, 데이터의 조회와 변경이 빈번하다면 압축은 고려하지 않는 것이 좋다.
    - 압축 알고리즘은 예상외로 많은 CPU 자원을 소모한다.

### 6.2.3 압축된 페이지의 버퍼 풀 적재 및 사용
- InnoDB 스토리지 엔진은 압축된 테이블의 데이터 페이지를 버퍼 풀에 적재하면 압축된 상태와 압축이 해제된 상태 2개 버전을 관리한다.
  - 디스크에서 읽은 상태 그대로의 데이터 페이지 목록을 관리하는 LRU 리스트
  - 압추된 페이지들의 압축 해제 버전인 Unzip_LRU 리스트

결국 InnoDB 스토리지 엔진은 압축된 테이블에 대해서는 버퍼 풀의 공간을 이중으로 사용함으로써 메모리를 낭비하는 효과를 가진다.
- 또한 압축된 페이지에서 데이터를 읽거나 변경하기 위해서는 압축을 해제해야 한다는 것인데, 압축 및 압축 해제 작업은 CPU를 상대적으로 많이 소모하는 작업이다.

=> 이런 두 가지 단점을 보완하기 위해 Unzip_LRU를 별도로 관리하고 있다가 MySQL 서버로 유입되는 요청 패턴에 따라 적절히(Adaptive) 다음과 같은 처리를 수행한다.

```
1. InnoDB 버퍼 풀의 공간이 필요한 경우
- LRU 리스트에서 원본 데이터 페이지는 유지 & 압축 해제된 Unzip_LRU는 제거

2. 압축된 데이터 페이지가 자주 사용되는 경우에는 Unzip_LRU에 압축 해제된 페이지를 계속 유지하여 압축 및 해제 작업을 최소화한다.

3. 압축된 데이터 페이지가 사용되지 않아 LRU 리스트에서 제거되는 경우에 Unzip_LRU 리스트에서도 함께 제거된다.
```

또한, InnoDB 스토리지 엔진은 버퍼 풀에서 압축 해제된 버전의 데이터 페이지를 적절한 수준으로 유지하기 위해 다음과 같은 어댑티브 알고리즘을 사용한다.

```
1. CPU 사용량이 높은 서버
- 가능한 압축, 해제를 줄이기 위해 Unzip_LRU 비율을 높혀서 유지
2. Disk IO 사용량이 높은 서버
- Unzip_LRU 비율을 낮춰서 InnoDB 버퍼 풀 메모리 공간을 더 확보하도록 작동
```

### 6.2.4 테이블 압축 관련 설정
- 테이블 압축을 사용하기 위한 연관된 시스템 변수가 몇 가지 있는데, 모두 페이지의 압축 실패율을 낮추기 위해 필요한 튜닝 포인트를 제공한다.