## 4.1.2 MySQL 스레딩 구조

### 1. MySQL 스레딩 구조

| 스레드 종류 | 설명 |
|-------------|------|
| **메인 스레드** | 서버 초기화, 관리 작업 수행 |
| **포그라운드 스레드** | 클라이언트 요청 처리 (쿼리 실행 등) |
| **백그라운드 스레드** | 로그 플러시, 버퍼 정리 등 내부 관리 작업 수행 |

기본적으로 클라이언트가 연결되면 **포그라운드 스레드가 하나 생성되어 1:1로 연결**된다.

### 2. 전통적인 스레드 모델 (1:1 구조)

- **커넥션 1개당 포그라운드 스레드 1개**가 생성된다.
- 클라이언트가 쿼리를 보내든 안 보내든, 스레드는 커넥션과 계속 연결되어 있다.
- 클라이언트 수가 많아지면 스레드도 무제한으로 증가하게 된다.

#### 문제점
- 메모리 사용량 증가
- **컨텍스트 스위칭** 부담 (스레드 전환 시 CPU 자원 낭비)
- CPU 캐시 효율 감소
- 스레드 생성/제거 오버헤드

### 3. 스레드 풀 모델 (1:N 구조)

MySQL 5.6 이상에서는 `thread_handling=pool-of-threads` 설정을 통해 스레드 풀 방식을 사용할 수 있다.

- 고정된 수의 스레드(작업자)를 풀로 만들어 둔다.
- 클라이언트가 쿼리를 보낼 때마다 스레드가 요청을 처리하고, 끝나면 다시 풀로 돌아간다.
- 스레드 1개가 여러 커넥션의 요청을 순차적으로 처리한다.
- 특히 **짧은 쿼리나 연결이 많지만 작업량이 적은 시스템**에서 큰 성능 향상을 기대할 수 있다.
- **스레드 풀 모델은** 포그라운드 스레드를 재사용하여, 더 **적은 자원으로 더 많은 요청을 효율적으로 처리**할 수 있도록 설계된 구조다.

| 항목 | 전통 구조 (1:1) | 스레드 풀 구조 (1:N) |
|------|------------------|------------------------|
| 커넥션당 스레드 | 1개 | 없음 (공용 풀 사용) |
| 스레드 수 | 커넥션 수만큼 증가 | 고정 |
| 리소스 소비 | 많음 | 적음 |
| 처리 방식 | 커넥션 전용 스레드 유지 | 요청 시 스레드 임대/반납 |
| 장점 | 단순 | 경량화, 확장성 ↑ |

### 4. 왜 CPU 코어 수보다 많은 스레드가 있으면 성능이 저하될까?

CPU는 한 번에 코어 수만큼만 스레드를 **병렬로** 실행할 수 있다.  
코어 수보다 많은 스레드가 생기면, 운영체제는 다음과 같은 일을 하게 된다:

- **스케줄링**: 어떤 스레드를 실행할지 계속 교체
- **컨텍스트 스위칭**: 실행 중인 스레드 상태 저장 + 새 스레드 상태 불러오기
- **캐시 미스 증가**: CPU 캐시에 있던 데이터가 사라지고 다시 로딩 필요

이로 인해 오히려 **CPU 사용률은 높아지지만, 처리량은 감소**하는 현상이 발생한다.  
즉, **스레드가 많을수록 항상 좋은 건 아니며**, 오히려 병목이 될 수 있다.

#### 4.1 왜 컨텍스트 스위칭이 “부담”인가?

1. 오버헤드 발생

- 컨텍스트 스위칭 시, CPU는 현재 스레드의 **상태(문맥)**를 저장하고,
  다음 스레드의 상태를 **복구**해야 한다.
- 이 작업은 **쿼리 처리와 직접적인 관련이 없는 부수 작업**이다.
- 따라서, 스레드가 많을수록 **실제 유용한 작업보다 전환 작업에 자원이 낭비**된다.

2. CPU 캐시 미스 증가

- CPU는 실행 중인 스레드의 데이터를 **L1/L2 캐시**에 저장한다.
- 스레드가 전환되면, 캐시된 데이터가 **무효화**되고,  
  다음 스레드의 데이터를 다시 메모리에서 **불러와야 한다**.
- 이는 **메모리 접근 지연(latency)**을 유발하고, 전체 처리 속도를 늦춘다.

3. 실행 지연

- 스레드 전환에는 시간이 소요된다.  
  상태 저장 + 복구 + CPU 레지스터 교체 + 스택 포인터 변경 등이 포함된다.
- 이로 인해 **실제 작업을 시작하기까지 지연이 발생**하게 된다.

4. 스케줄링 비용

- OS 커널은 어떤 스레드를 다음에 실행할지 **결정(scheduling)** 해야 한다.
- 이 과정에서:
    - 스레드의 우선순위,
    - 대기 시간,
    - I/O 상태 등을 고려해야 한다.
- 이 역시 **CPU가 직접적인 생산 작업이 아닌 관리 작업에 자원을 쓰는 상황**이다.

---

## 4.1.3 메모리 할당 및 사용 구조

### 1. 글로벌 메모리 영역 (Global Memory)

- 서버 전체에서 공통적으로 사용하는 메모리 영역
- 서버가 시작될 때 할당되고, 서버가 종료될 때까지 유지됨
- 예시:
    - InnoDB 버퍼 풀 (`innodb_buffer_pool_size`)
    - 키 캐시 (MyISAM)
    - 쿼리 캐시
    - Binary Log 캐시

#### 특징
- 서버 단위로 하나만 존재
- 크기를 주의해서 설정해야 함 (너무 크면 OOM 위험, 너무 작으면 성능 저하)

### 2. 로컬 메모리 영역 (Local Memory)

- 각 커넥션마다 별도로 할당되는 메모리 영역
- 커넥션이 열려 있을 때 또는 쿼리 실행 시점에 동적으로 할당됨
- 예시:
    - 커넥션 버퍼 (`net_buffer_length`, `max_allowed_packet`)
    - 쿼리 캐시
    - 소트 버퍼 (`sort_buffer_size`)
    - 조인 버퍼 (`join_buffer_size`)
    - 임시 테이블 메모리

#### 로컬 메모리의 위험성

로컬 메모리는 커넥션 수만큼 곱해져서 전체 메모리 사용량이 폭발적으로 증가할 수 있다.

#### 최악의 경우
- `sort_buffer_size`, `join_buffer_size`, `read_buffer_size` 등을 너무 크게 설정한 경우
- 커넥션 수가 많아지면 각 커넥션마다 이 버퍼가 따로 할당됨
- 메모리 부족(OOM: Out of Memory)으로 MySQL 프로세스가 비정상 종료될 수 있음

### 두 가지 버퍼 타입 차이

| 구분 | 설명 | 예시 |
|------|------|------|
| 지속적 버퍼 | 커넥션이 열려 있는 동안 계속 유지됨 | 커넥션 버퍼, 결과 버퍼 |
| 일시적 버퍼 | 쿼리 실행 시점에만 잠깐 할당됨 | 소트 버퍼, 조인 버퍼 |

#### 예시
- `net_buffer_length`, `max_allowed_packet` → 커넥션과 함께 살아있음
- `sort_buffer_size`, `join_buffer_size` → 쿼리 실행 시 생성되고, 끝나면 해제됨

> max_prepared_stmt_count 초과 에러와 메모리의 관계  
`ERROR 1461 (42000): Can’t create more than max_prepared_stmt_count statements`  
`prepared statement`는 **지속적 버퍼**로, 커넥션 단위로 메모리에 상주한다. 이 개수가 많아지면 MySQL 전체 메모리 점유율이 증가한다.  

---

## 4.1.8 쿼리 캐시

### 쿼리 캐시(Query Cache) vs CPU 캐시

쿼리 캐시는 SQL 실행 결과를 메모리에 저장해두고,  
동일한 SQL이 들어오면 DB를 다시 조회하지 않고 **바로 결과를 반환**한다.

이 개념은 CPU 캐시와 매우 비슷해 보인다:

| 항목 | 쿼리 캐시 | CPU 캐시 |
|------|-----------|----------|
| 캐시 대상 | SQL 실행 결과 | 메모리 주소의 데이터 |
| 캐시 무효화 | 관련 테이블 변경 시 | 메모리 값 변경 시 |
| 캐시 키 | SQL 문자열 그대로 | 메모리 주소 |
| 장점 | I/O 및 쿼리 실행 시간 절감 | 메모리 접근 속도 향상 |
| 무효화 범위 | 해당 테이블 관련 모든 쿼리 | 해당 캐시 라인 또는 페이지 |

#### 유사한 점
- **정확히 일치하는 입력에 대해 결과를 빠르게 재사용**한다는 점에서 유사함
- **변경이 발생하면 무효화**가 필요하다는 구조도 비슷함

#### 차이점
- CPU 캐시는 하드웨어 차원에서 **정밀하게 무효화** 가능 (라인 단위)
- 쿼리 캐시는 **전체 쿼리 문자열이 동일해야만 재사용** 가능 → 재사용 효율이 낮음
- 쿼리 캐시는 **논리적 관계를 파악하지 못하고**, **테이블이 바뀌면 관련된 모든 쿼리 캐시를 무효화**해버림

### MySQL에서 쿼리 캐시가 제거된 이유

MySQL 8.0부터 **쿼리 캐시 기능이 완전히 제거**되었다.  
가장 큰 이유는 **성능 저하와 복잡한 버그** 때문이었다.

#### 1. 쓰기 중심 워크로드에서 캐시 무효화가 과도하게 발생

- 한 테이블에 쓰기(insert/update/delete)가 발생하면,
  **그 테이블을 참조하는 모든 쿼리 캐시가 삭제됨**
- 읽기보다 쓰기가 많으면 캐시가 자주 무효화되어 **효과가 거의 없음**
- 캐시를 유지하느라 오히려 **락 경합 및 부하가 증가**

#### 2. 캐시 일관성 유지 비용

- 캐시에 어떤 쿼리가 어떤 테이블에 의존하는지 추적해야 함
- 이 과정에서 **추가적인 내부 오버헤드**가 발생하고,
  캐시 무효화 로직이 **복잡한 버그의 원인**이 되었음

#### 3. 캐시 락으로 인한 동시성 병목

- 쿼리 캐시는 MySQL 내부에서 **글로벌 락**으로 보호되었음
- 즉, 여러 스레드가 동시에 캐시를 접근하면 **락 경합**이 발생
- 고성능 워크로드에서는 오히려 **쿼리 캐시 때문에 TPS가 줄어드는 현상**도 보고됨

#### 대표적인 문제 사례

- 하나의 빈번한 INSERT 쿼리 때문에 **전체 캐시가 자주 날아가**서 캐시 적중률이 급감
- SELECT 쿼리는 캐시를 계속 생성하고, 다른 쓰기 쿼리는 그걸 바로 무효화하는 구조
- 결과적으로 캐시는 계속 **만들고 날리는 악순환** → 성능 저하

그래서 MySQL 8.0에서는 쿼리 캐시를 제거했고,  
대신 **애플리케이션 레벨 캐시(Redis 등)** 또는 **InnoDB Buffer Pool** 같은  
다른 캐싱 메커니즘을 사용하는 것이 권장된다.

---

## 4.2.2 외래 키 지원
데드락이 발생할 때가 많으므로 개발할 때도 외래키의 존재에 주의하는 것이 좋다.

[외래 키로 인해 발생했던 데드락 사례 정리글](https://velog.io/@haron/%EC%99%B8%EB%9E%98%ED%82%A4Foreign-Key%EC%99%80-%EB%8D%B0%EB%93%9C%EB%9D%BDDeadLock-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%BF%BC%EB%A6%AC-%EC%A7%80%EC%97%B0-%EC%8B%A4%ED%96%89-eruedsy4)

## 4.2.5 자동 데드락 감지

### 자동 데드락 감지와 `innodb_deadlock_detect`

InnoDB는 기본적으로 **데드락을 감지하는 스레드**를 두고,
트랜잭션 간 교착 상태가 발생했을 때 **자동으로 하나를 롤백**시킨다.

#### 1. 데드락 감지 방식

- 트랜잭션 간 잠금 대기 그래프(Lock Wait Graph)를 생성하여 **사이클을 탐지**함
- 일반적으로 **Undo 로그 레코드를 적게 가진 트랜잭션**을 **롤백 대상**으로 삼는다
    - 이유: 롤백 비용이 낮기 때문

#### 2. 성능 저하 발생 원인

- 동시 트랜잭션 수가 많고, 각 트랜잭션이 **많은 잠금을 소유**하는 경우
- 데드락 감지 스레드는 모든 잠금 대기 관계를 순회해야 하므로
    - **복잡도: O(n^2)** 이상
    - 데드락 탐지 자체가 **CPU 병목점**이 될 수 있음

#### 3. `innodb_deadlock_detect = OFF` 성능 향상 이유 (Google 사례 등)

- 데드락 감지 스레드를 완전히 비활성화하면,  
  복잡한 그래프 순회 연산을 하지 않아도 됨 → **CPU 부하 감소**
- 특히 **짧은 트랜잭션이 매우 많은 시스템**에서는  
  데드락 감지보다 **간단한 타임아웃 처리 방식이 훨씬 가볍고 빠름**
- Google은 내부적으로 데드락보다 **lock wait timeout**을 더 빠르게 처리하도록 설계

#### 4. `innodb_deadlock_detect = OFF`로 하면 데드락 감지가 안 되는가?

맞다. 이 설정을 끄면 **InnoDB는 데드락 감지를 하지 않는다.**

- 대신, `innodb_lock_wait_timeout` 시간이 지나야 **트랜잭션이 수동으로 종료**된다
- 즉, 데드락이 발생해도 시스템이 바로 알아차리지 못하고,  
  **timeout 시간만큼 기다린 뒤에야 트랜잭션을 종료**한다

#### 5. 그럼 timeout만으로도 데드락 해결이 가능한가?

- **"완벽하게 해결"은 안 된다**
    - 데드락은 즉시 감지해야 시스템 자원 낭비를 막을 수 있음
- 하지만 timeout 기반 접근은 **간단하고, 성능이 더 중요한 시스템에서 실용적**
    - ex) 대규모 짧은 트랜잭션 처리 시스템 (Google Spanner, Cloud SQL 등)

#### 정리

| 항목 | 설명 |
|------|------|
| `innodb_deadlock_detect = ON` | 데드락 즉시 탐지, 더 안정적이나 고부하 시 오버헤드 발생 |
| `innodb_deadlock_detect = OFF` | 성능 향상 가능, 대신 timeout 기반으로 처리됨 |
| `innodb_lock_wait_timeout` | 데드락 감지를 끈 경우, 이 시간만큼 기다린 후 롤백 발생 |

**주의**: `innodb_deadlock_detect`를 끄면 데드락이 **즉시 해결되지 않고 지연 처리**되므로,  
어떤 트랜잭션이 오래 기다릴 수 있고, 사용자에게 **오류 응답 지연**이 생길 수 있다.

---

## 4.2.7 InnoDB 버퍼풀

### InnoDB 버퍼 풀(Buffer Pool) 구조 정리

InnoDB 버퍼 풀은 **디스크 I/O를 줄이고 성능을 높이기 위해**,  
데이터와 인덱스를 **메모리에 캐싱**해두는 구조이다.

### 1. 버퍼 풀은 어떻게 구성되는가?

- `innodb_buffer_pool_size`로 전체 크기를 설정한다.
- 내부적으로는 **128MB 단위의 청크(Chunk)**로 쪼개어 관리된다.
- 각 청크는 다시 **페이지(16KB 단위)**로 나뉘며, 실제 데이터를 저장한다.

### 2. 전통적인 구조의 문제점

- 초창기 InnoDB는 **전체 버퍼 풀을 하나의 세마포어(잠금)**로 보호했다.
- 다중 스레드가 동시에 버퍼 풀에 접근하면,
  **버퍼 풀 전역 잠금**으로 인해 **락 경합(Lock Contention)**이 발생했다.
- 특히 대용량 시스템이나 다중 코어 환경에서는 **병목**으로 작용했다.

### 3. 개선된 구조: 버퍼 풀 파티셔닝

- InnoDB는 **버퍼 풀을 여러 개의 인스턴스(instance)**로 나누는 방식을 도입했다.
- 각 인스턴스는 **자체 세마포어**를 가지고 있고,  
  해당 영역에 접근하는 스레드들만 경합한다.

#### 효과:
- **버퍼 풀 잠금이 분산됨**
- **동시성 증가**
- **락 경합 감소**
- CPU 코어를 더 효율적으로 활용 가능

---

## 4.2.7 InnoDB 버퍼 풀

### InnoDB 더티 페이지와 리두 로그(Redo Log)의 관계

### 기본 개념

- InnoDB는 **데이터 페이지를 버퍼 풀에 먼저 반영**하고,
  디스크에는 **나중에 체크포인트 시점에 반영**한다 (Write-Behind)
- 더티 페이지란: **메모리에는 변경됐지만 디스크에는 아직 반영되지 않은 페이지**
- 이 변경 내용은 리두 로그(Redo Log)에 먼저 기록된다.

### 체크포인트(Checkpoint)와 더티 페이지

- 체크포인트가 발생하면:
    - **Checkpoint LSN 이전에 해당하는 리두 로그 엔트리**
    - 와 관련된 **더티 페이지는 반드시 디스크로 플러시**되어야 한다.
- 이유: 해당 로그들이 삭제될 수 있기 때문에, **복구 가능성을 보장하기 위해**.

### 리두 로그 vs 더티 페이지: 수용량 계산

리두 로그가 커야 → 더 많은 더티 페이지의 변경 이력을 **기록하고 유지**할 수 있다.  
즉, **리두 로그 크기는 허용 가능한 더티 페이지 수를 제한**하는 요소다.

---

## 4.2.9 언두 로그

### InnoDB 더티 페이지와 리두 로그(Redo Log)의 관계

### 기본 개념

- InnoDB는 **데이터 페이지를 버퍼 풀에 먼저 반영**하고,
  디스크에는 **나중에 체크포인트 시점에 반영**한다 (Write-Behind)
- 더티 페이지란: **메모리에는 변경됐지만 디스크에는 아직 반영되지 않은 페이지**
- 이 변경 내용은 리두 로그(Redo Log)에 먼저 기록된다.

### 체크포인트(Checkpoint)와 더티 페이지

- 체크포인트가 발생하면:
    - **Checkpoint LSN 이전에 해당하는 리두 로그 엔트리**
    - 와 관련된 **더티 페이지는 반드시 디스크로 플러시**되어야 한다.
- 이유: 해당 로그들이 삭제될 수 있기 때문에, **복구 가능성을 보장하기 위해**.

### 리두 로그 vs 더티 페이지: 수용량 계산

리두 로그가 커야 → 더 많은 더티 페이지의 변경 이력을 **기록하고 유지**할 수 있다.  
즉, **리두 로그 크기는 허용 가능한 더티 페이지 수를 제한**하는 요소다.

---

## 4.2.12 어댑티브 해시 인덱스

### Adaptive Hash Index (AHI)

Adaptive Hash Index는 InnoDB에서 자주 접근되는 인덱스 페이지에 대해  
**자동으로 해시 인덱스를 생성하여 조회 성능을 향상**시키는 기능이다.

### 1. 왜 해시 인덱스를 사용할까?

InnoDB의 기본 인덱스는 **B+ Tree 구조**이다.

- B+ Tree는 범위 조회에 적합하지만,
- **동일한 조건의 반복적인 단일 키 조회**에서는 해시가 더 빠르다.

→ AHI는 **B+ Tree 인덱스를 그대로 유지**하면서  
자주 사용되는 키에 대해서만 **추가로 해시 인덱스를 생성**해 최적화한다.

### 2. 동작 방식

1. 쿼리 수행 시 B+ Tree로 인덱스 페이지를 탐색
2. 특정 키 조회가 **짧은 시간 안에 여러 번 발생**하면
3. InnoDB가 해당 키에 대한 해시 엔트리를 **자동 생성**
4. 다음부터는 해당 키 조회 시 해시 인덱스를 사용 → **빠른 탐색**

#### 특징

- **사용자 설정 없이 자동 생성/제거**
- 메모리 내에만 존재 (디스크 저장 X)
- 해시 테이블은 **버퍼 풀 페이지를 기반으로 관리**됨

### 3. 장점

- 자주 조회되는 키는 **해시 인덱스로 빠르게 접근** 가능 (O(1)에 가깝다)
- 응답 속도 향상
- B+ Tree 인덱스를 유지하면서 **캐시 최적화 효과**까지 얻을 수 있다

### 4. 단점

- **락 경합** 문제가 발생할 수 있다  
  (특히 여러 스레드가 AHI를 동시에 갱신하려 할 때)
- AHI의 관리 자체가 CPU 리소스를 추가로 소모
- 일관된 쿼리 패턴이 없거나 조회 키가 다양하면 **효과가 거의 없다**

### 5. MySQL 8.0의 변화

MySQL 8.0에서는 AHI 관련 **락 경합 문제를 해결하기 위해**  
**AHI를 샤딩(sharding)** 구조로 바꾸었다.
