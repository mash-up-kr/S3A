# RealMySQL1

# 4. 아키텍처

## 4.1 MySQL 엔진 아키텍처

MySQL 서버는 `머리 역할을 하는 MySQL 엔진`과 `손발 역할을 담당하는 스토리지 엔진`으로 구분됨

손과 발을 담당하는 스토리지 엔진은 핸들러 API를 만족하면 누구던 스토리지 엔진을 구현해서 MySQL 서버에 추가해요 사용 가능

이번 장에서 MySQL 엔진과 기본으로 제공되는 InnoDB 스토리지 엔진, MyISAM 스토리지 엔진을 구분해서 학습

### 4.1.1 MySQL의 전체 구조
// 1-1 이미지

#### 4.1.1.1 MySQL 엔진

클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룸

#### 4.1.1.2 스토리지 엔진

MySQL 엔진은 요처된 SQL 문장을 분석하거나 최적화하는 등 두뇌에 해당하는 처리를 수행

스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담

MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있음

#### 4.1.1.3 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이를 핸들러 요청이라고함

여기서 사용되는 API를 핸들러 API 라고함

InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MySQL엔진과 데이터를 주고 받음

### 4.1.2 MySQL 스레딩 구조
// 1-2 이미지

MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동하며 크게 포그라운드 스레드와 백그라운드 스레드로 구분함

#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수 만큼 존재하며 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리

커넥션을 종료하면 스레드는 스레드 캐시로 돌아감. 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있다면 넣지 않고 종료시킴. thread_cache_size 시스템 변수로 설정함

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오지만 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어옴

`MyISAM 테이블`은 디스크 쓰기 작업까지 포그라운드 스레드가 처리함

`InnoDB 테이블`은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리

#### 4.1.2.2 백그라운드 스레드

MyISAM은 해당 사항이 별로 없지만 InnoDB는 아래와 같이 여러 가지 작업이 백그라운드로 처리됨

- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

그렇기때문에, MyISAM은 사용자가 쓰기 작업까지 한번에 작업하고, 쓰기 버퍼링 기능을 사용할 수 없음

InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될떄까지 기다리지 않아도 됨

### 4.1.3 메모리 할당 및 사용 구조
// 1-3 이미지

MySQL에서 사용된느 메모리 공간은 글로벌 메모리 영역과 롴러 메모리 영역으로 구분됨

글로벌 메모리 영역의 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당됨

MySQL의 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는다고 생각해도 됨

글로벌 메모리 영역과 로컬 메모리 영역은 MySQL 서버 내의 스레드의 공유 여부에 따라 구분됨

#### 4.1.3.1 글로벌 메모리 영역

스레드가 10개든 100개든 InnoDB 버퍼 풀 같은 메모리공간은 1개만 존재하고 모든 스레드가 이것을 공유해서 사용함

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

#### 4.1.3.2 로컬 메모리 영역

MySQL 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역

- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 4.1.4 플러그인 스토리지 엔진 모델

// 1-4 이미지

상태 변수 중에서 `Handler_`로 시작하는 변수는 MySQL엔진이 각 스토리지 엔진에게 보낸 명령의 횟수를 의미하는 변수

// 1-5 이미지
MySQL에서 MyISAM이나 InnoDB와 같이 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행하더라도 MySQL의 처리 내용은 대부분 동일하며 데이터 읽기/쓰기 영역의 처리만 차이가 있음

MySQL 서버에서는 스토리지 엔진뿐만 아니라 다양한 기능을 플러그인 형태로 지원함

인증이나 전문 검색 파서 또는 쿼리 재작성과 같은 플러그인 이 있고 비밀번호 검증과 커넥션 제어 등 다양한 플러그인이 존재

### 4.1.5 컨포넌트

MySQL 8.0부터는 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원됨

MySQL 서버의 플러그인은 아래와 같은 단점이 있는데 컴포넌트는 이 단점들을 보완되어 구현됐음

- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
- 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음 (캡슐화 안 됨)
- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

### 4.1.6 쿼리 실행 구조

// 1-6 이미지

#### 4.1.6.1 쿼리 파서

사용자 요청으로 들어온 문장을 토큰(MySQL이 인식할 수 있는 단위)으로 분리해 트리 형태의 구조로 만들어내는 작업을 의미

쿼리의 문법 옹류는 이곳에서 발견함

#### 4.1.6.2 전처리기

문법 오류가 아닌 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰이 이 단계에서 걸러짐

#### 4.1.6.3 옵티마이저

사용자의 요청의 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할

DBMS의 두뇌

어떻게하면 옵티마이저가 더 나은 선택을 할 수 있게 유도하는가를 학습

#### 4.1.6.4 실행 엔진

옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발로 비유

옵티마이저는 회사 경영진, 실행 엔진은 중간 관리자, 핸들러는 각 업무의 실무자

ex) 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정

1. 실행 엔진이 핸들러에게 임시 테이블을 만들어달라고 요청
2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

결론적으로 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

#### 4.1.6.5 핸들러(스토리지 엔진)

핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 담당

핸들러는 스토리지 엔진을 의미하고 MyISAM 테이블을 조직하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우에는 InnoDB 스토리지 엔진이 됨

### 4.1.7 복제

16장 복제에서 학습

### 4.1.8 쿼리 캐시

쿼리의 결과를 캐시에 저장하는 기능이지만 변경된 테이블을 모두 삭제하여야하므로 동시 처리 성능 저하를 유발함

MySQL 8.0 부터 제거됨

### 4.1.9 스레드 풀

MySQL 엔터프라이즈는 스레드 풀 기능을 제공하지만 커뮤니티 에디션은 지원하지 않음

아래에서 언급하는 스레드 풀은 엔터프라이즈에서 제공하는 스레드 풀이 아닌 Percona Server에서 제공하는 스레드 풀 기능

플러그인 형태로 작동하게 구현되어있으므로 플러그인 라이브러리를 MySQL 커뮤니티 에디션에 설치해서 사용하면 됨

스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많아도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 하여 서버의 자우너 소모를 줄이는 것이 목적

스레드 풀이 실제 서비스에서 눈에 띄는 성능 향상을 보여준 경우는 드뭄

Percona Server의 스레드풀은 CPU 코어의 개수와 스레드풀 개수를 맞추는 것이 CPU 프로세서 친화도를 높이는데 좋음

MySQL 서버가 처리해야 할 요청이 생기면 스레드 풀로 처리를 이관하는데 스레드 풀이 실행 중이면 추가적으로 처리함

이 값이 너무 크다면 스케줄링해야 할 스레드가 많아져 스레드 풀이 비효율적으로 작동할 수도 있음

// 1-7 이미지

그림 4.7 - 사용자 요청이 유입된 순서
→ 사용자 3명이 트랜잭션(BEGIN → QUERY/COMMIT)을 보내면,
스레드 풀은 유입된 순서 그대로 처리한다.
→ 일반적인 처리 방식이며, 처리 효율이 떨어질 수 있음.

그림 4.8 - Percona Server의 우선순위 큐 기반 재정렬
→ Percona는 스레드 풀 내부에서 요청을 재배치함.
→ 이미 트랜잭션이 시작된 쿼리(QUERY, COMMIT)를 **선순위 큐**로 우선 처리.
→ 아직 시작되지 않은 트랜잭션(BEGIN)은 **후순위 큐**로 밀려나 대기.
→ 이렇게 하면 락을 오래 잡고 있는 쿼리를 빨리 해소시켜
전체 처리 성능(동시성, 응답속도)이 향상됨.

### 4.1.10 트랜잭션 지원 메타데이터

MySQL 8.0 버전부터는 기존 파일 기반의 데이터 저장 방식에서 InnoDB의 테이블에 저장하도록 변경하여 메타데이터의 트랜잭션을 보장함

MySQL 서버가 작동하기 위해 기본적으로 필요한 테이블을 시스템 테이블이라하고 이것 또한 MySQL 8.0 버전부터는 InnoDB 스토리지 엔진을 사용하도록 개선됨

시스템 테이블과 데이터 딕셔너리 정보를 모두 모아 mysql DB에 저장함

mysql DB는 통째로 mysql.ibd라는 이름의 테이블스페이스에 저장함

그래서 MySQL 서버의 데이터 디렉터리에 존재하는 mysql.ibd라는 파일은 다른 *.ibd 파일과 함께 주의해야함

## 4.2 InnoDB 스토리지 엔진 아키텍처

// 이미지 1-8

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금(행 단위 잠금)을 제공하여 높은 동시성 처리가 가능함

### 4.2.1 프라이머리 키에 의한 클러스터링

InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장됨

즉 프라이머리 키 값의 순서대로 디스크에 저장되며 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용함

클러스터링 인덱스(InnoDB)는
- 프라이머리 키를 기준으로 정렬된 B+ Tree
- 리프 노드에 "해당 row의 모든 컬럼 값"이 저장됨 (== 데이터 자체)

그래서 "인덱스가 곧 데이터"라고 부름

MyISAM은
- 인덱스는 프라이머리 키 값 + 데이터 위치(ROWID)만 저장
- 실제 데이터는 다른 곳에 따로 저장됨
